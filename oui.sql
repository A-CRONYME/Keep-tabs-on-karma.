-- ===================================================================
-- 1. DEFINE CUSTOM TYPES (ENUMS) FOR DATA CONSISTENCY 8===D
-- ===================================================================


CREATE TYPE foe_category_enum AS ENUM (
  'Ex-Partner',
  'Former Boss',
  'Bully',
  'Rival',
  'Business Foe',
  'Other'
);

CREATE TYPE status_update_type_enum AS ENUM (
  'Career',
  'Personal',
  'Karma',
  'General'
);


-- ===================================================================
-- 2. CREATE THE CORE TABLES
-- ===================================================================

-- Table to store the main "foes" on a user's list.
CREATE TABLE foes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  category foe_category_enum NOT NULL,
  notes TEXT, -- Optional private notes for the user
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,

  -- A user cannot add the exact same foe (by name) twice
  UNIQUE (user_id, name)
);


CREATE TABLE status_updates (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  foe_id BIGINT NOT NULL REFERENCES foes(id) ON DELETE CASCADE,
  type status_update_type_enum NOT NULL,
  text TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);


-- ===================================================================
-- 3. CREATE INDEXES FOR PERFORMANCE
-- ===================================================================

CREATE INDEX idx_foes_user_id ON foes(user_id);

-- status updates for a specific foe
CREATE INDEX idx_status_updates_foe_id ON status_updates(foe_id);


-- ===================================================================
-- 4. CREATE TRIGGER TO AUTO-UPDATE 'updated_at'
-- ===================================================================


-- trigger function that can be reused for any table
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$ BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
 $$ LANGUAGE plpgsql;

-- rigger to the 'foes' table
CREATE TRIGGER set_foes_timestamp
BEFORE UPDATE ON foes
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();

--  trigger to the 'status_updates' table
CREATE TRIGGER set_status_updates_timestamp
BEFORE UPDATE ON status_updates
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();


-- ===================================================================
-- 5. ENABLE ROW LEVEL SECURITY (RLS)
-- ===================================================================


ALTER TABLE foes ENABLE ROW LEVEL SECURITY;
ALTER TABLE status_updates ENABLE ROW LEVEL SECURITY;


-- ===================================================================
-- 6. CREATE RLS POLICIES
-- ===================================================================


-- Policies for the 'foes' table
CREATE POLICY "Users can view their own foes." ON foes
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own foes." ON foes
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own foes." ON foes
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own foes." ON foes
  FOR DELETE USING (auth.uid() = user_id);

-- Policies for the 'status_updates' table
--  must check 'foe_id' 


CREATE POLICY "Users can view updates for their own foes." ON status_updates
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM foes WHERE foes.id = status_updates.foe_id AND foes.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert updates for their own foes." ON status_updates
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM foes WHERE foes.id = status_updates.foe_id AND foes.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update updates for their own foes." ON status_updates
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM foes WHERE foes.id = status_updates.foe_id AND foes.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete updates for their own foes." ON status_updates
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM foes WHERE foes.id = status_updates.foe_id AND foes.user_id = auth.uid()
    )
  );


-- ===================================================================
-- 7. CREATE A HELPER FUNCTION FOR EFFICIENT DATA FETCHING BITE 8===D
-- ===================================================================


CREATE OR REPLACE FUNCTION get_foes_with_updates(p_user_id UUID)
RETURNS TABLE (
  id BIGINT,
  name TEXT,
  category foe_category_enum,
  notes TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  status_updates JSONB -- Nested updates JSON array
) AS $$ BEGIN
  RETURN QUERY
  SELECT
    f.id,
    f.name,
    f.category,
    f.notes,
    f.created_at,
    f.updated_at,
    -- updates into a JSON array
    COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'id', su.id,
          'type', su.type,
          'text', su.text,
          'created_at', su.created_at
        ) ORDER BY su.created_at DESC
      ) FILTER (WHERE su.id IS NOT NULL), '[]'::jsonb
    ) AS status_updates
  FROM
    foes f
  LEFT JOIN
    status_updates su ON f.id = su.foe_id
  WHERE
    f.user_id = p_user_id
  GROUP BY
    f.id, f.name, f.category, f.notes, f.created_at, f.updated_at
  ORDER BY
    f.updated_at DESC; -- Show recently updated foes first
END;
 $$ LANGUAGE plpgsql SECURITY DEFINER;

